(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[6],{

/***/ "./writings/filtering-js-arrays.md":
/*!*****************************************!*\
  !*** ./writings/filtering-js-arrays.md ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: \"Filtering arrays in JavaScript\"\ndate: \"2020-04-23\"\nog:\n  description: \"Learn how to use the filter with arrays in JavaScript\"\n  image: \"https://telmo.im/og/arrayfilter.png\"\nauthor:\n  twitter: \"telmo\"\n  name: \"Telmo Goncalves\"\n---\n\nUsing `filter()` in JavaScript can be really handy, you can filter an\narray in so many ways, lets explore a little bit about that.\n\n<br />\n\n## Numbers\n\nStart with a simple numbers array:\n\n```js\nconst array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n```\n\nNow, lets filter this array in order to return only values below `8`:\n\n```js:3-5\nconst array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// We're *saying*, get me all values\n// that are less less (<) than 8\narray.filter(value => value < 8);\n```\n\nWith this filter it'll return `[1, 2, 3, 4, 5, 6, 7]`, pretty neat right?\n\n<br />\n\nLets try a few more examples before moving on. Check the comments on the code:\n\n```js\nconst array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Get only odd numbers\narray.filter(value => value & 1); // [1, 3, 5, 7, 9]\n\n// Get only even numbers\narray.filter(value => !(value & 1)); // [2, 4, 6, 8, 10]\n\n// Get values between `3` and `8`\narray.filter(value => value > 3 && value < 8); // [4, 5, 6, 7]\n```\n\nAs you can see we can use `filter()` in many ways, lets play\na little bit with `strings` üôÇ\n\n---\n\n## Strings\n\nAgain, lets set up a simple array:\n\n```js\nconst array = [\"@telmo\", \"https://telmo.im\", \"Fullstack Developer\"]\n```\n\nLets assume we want to filter just URLs, so, we\ncan filter strings that start with `http` as an example:\n\n```js:3\nconst array = [\"@telmo\", \"https://telmo.im\", \"Fullstack Developer\"];\n\narray.filter(value => value.startsWith(\"http\"));\n```\n\nThis will return `[\"https://telmo.im\"]`. I love JavaScript!\n\nSince we know handlers start with an `@`, we can do exactly the same\nthing to filter all handlers, lets add a few more entries into our array:\n\n```js\nconst array = [\n  \"Telmo\", \"@telmo\", \"@codinghubio\", \"Coding Hub\"\n]\n\narray.filter(value => value.startsWith(\"@\"));\n```\n\nThis should return `[\"@telmo\", \"@codinghubio\"]`, sweet!\n\n---\n\n## Objects\n\nFinally, lets just go through a more complex array, an array\nof objects, lets assume an array of profiles:\n\n```js\nconst profiles = [\n  { name: \"Telmo\", handler: \"@telmo\", followers: 1000 },\n  { name: \"Catalin\", handler: \"@catalinmpit\", followers: 2000 },\n  { name: \"Marc\", handler: \"@_marcba\", followers: 3000 },\n];\n```\n\nNow lets try and filter profiles that have more than `1000` followers:\n\n```js\nprofiles.filter(value => value.followers > 1000);\n```\n\nWith this filter you should get:\n\n```json\n[\n  {\n    \"name\": \"Catalin\",\n    \"handler\": \"@catalinmpit\",\n    \"followers\": 2000\n  },\n  {\n    \"name\": \"Marc\",\n    \"handler\": \"@_marcba\",\n    \"followers\": 3000\n  }\n]\n```\n\nIn the filter you can do another thing, which is destructuring the\n`followers` directly, like this:\n\n```js\nprofiles.filter(({ followers }) => followers > 1000);\n```\n\n---\n\nI was about to end this writing now, but... We can still use another\napproach into how we filter arrays.\n\n<br />\n\nLets assume we have an array with `numbers` and `strings`, and we\nwant to filter the array to return just the `strings`, how do we\ncheck in JavaScript if something is a `string`?\n\n```js\ntypeof something === \"string\"\n```\n\nRight, lets take the following example:\n\n```js\nconst array = [1, 3, \"Telmo\", 4, 6, \"@telmo\"];\n\n// We can use the `typeof` directly in the filter\narray.filter(value => typeof value === \"string\");\n```\n\nIt should return `[\"Telmo\", \"@telmo\"]`, awesome! But, we can\nrefactor this a little bit, assume you might want to use a function\nthat checks if *something* is a `string`, lets take a look:\n\n```js\nconst array = [1, 3, \"Telmo\", 4, 6, \"@telmo\"];\n\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n\narray.filter(isString);\n```\n\nThis returns exactly the same `[\"Telmo\", \"@telmo\"]`, but look how\nour `filter()` got much cleaner, and bonus, you can re-use the `isString()`\nfunction somewhere else.\n\n> Note that this is not a **right way** of doing things approach, you should use whatever you think is fits you best.\n\n<br />\n\nThat's it, hope it helped somehow ‚úåÔ∏è\n");

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vd3JpdGluZ3MvZmlsdGVyaW5nLWpzLWFycmF5cy5tZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFBZSxva0JBQXFnQiwySUFBMkksNkdBQTZHLHVPQUF1Tyw4REFBOEQscUZBQXFGLHlHQUF5Ryw2Y0FBNmMsc0RBQXNELG9XQUFvVywwT0FBME8sd0RBQXdELE1BQU0sZ0VBQWdFLE1BQU0seURBQXlELEtBQUssMklBQTJJLDREQUE0RCw4RkFBOEYsTUFBTSx1RkFBdUYsNklBQTZJLFlBQVksdUJBQXVCLGtkQUFrZCwwR0FBMEcsd1FBQXdRLDhCQUE4Qix1Q0FBdUMsR0FBRywyQkFBMkIsbVdBQW1XLEUiLCJmaWxlIjoic3RhdGljL2NodW5rcy82LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCItLS1cXG50aXRsZTogXFxcIkZpbHRlcmluZyBhcnJheXMgaW4gSmF2YVNjcmlwdFxcXCJcXG5kYXRlOiBcXFwiMjAyMC0wNC0yM1xcXCJcXG5vZzpcXG4gIGRlc2NyaXB0aW9uOiBcXFwiTGVhcm4gaG93IHRvIHVzZSB0aGUgZmlsdGVyIHdpdGggYXJyYXlzIGluIEphdmFTY3JpcHRcXFwiXFxuICBpbWFnZTogXFxcImh0dHBzOi8vdGVsbW8uaW0vb2cvYXJyYXlmaWx0ZXIucG5nXFxcIlxcbmF1dGhvcjpcXG4gIHR3aXR0ZXI6IFxcXCJ0ZWxtb1xcXCJcXG4gIG5hbWU6IFxcXCJUZWxtbyBHb25jYWx2ZXNcXFwiXFxuLS0tXFxuXFxuVXNpbmcgYGZpbHRlcigpYCBpbiBKYXZhU2NyaXB0IGNhbiBiZSByZWFsbHkgaGFuZHksIHlvdSBjYW4gZmlsdGVyIGFuXFxuYXJyYXkgaW4gc28gbWFueSB3YXlzLCBsZXRzIGV4cGxvcmUgYSBsaXR0bGUgYml0IGFib3V0IHRoYXQuXFxuXFxuPGJyIC8+XFxuXFxuIyMgTnVtYmVyc1xcblxcblN0YXJ0IHdpdGggYSBzaW1wbGUgbnVtYmVycyBhcnJheTpcXG5cXG5gYGBqc1xcbmNvbnN0IGFycmF5ID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXTtcXG5gYGBcXG5cXG5Ob3csIGxldHMgZmlsdGVyIHRoaXMgYXJyYXkgaW4gb3JkZXIgdG8gcmV0dXJuIG9ubHkgdmFsdWVzIGJlbG93IGA4YDpcXG5cXG5gYGBqczozLTVcXG5jb25zdCBhcnJheSA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF07XFxuXFxuLy8gV2UncmUgKnNheWluZyosIGdldCBtZSBhbGwgdmFsdWVzXFxuLy8gdGhhdCBhcmUgbGVzcyBsZXNzICg8KSB0aGFuIDhcXG5hcnJheS5maWx0ZXIodmFsdWUgPT4gdmFsdWUgPCA4KTtcXG5gYGBcXG5cXG5XaXRoIHRoaXMgZmlsdGVyIGl0J2xsIHJldHVybiBgWzEsIDIsIDMsIDQsIDUsIDYsIDddYCwgcHJldHR5IG5lYXQgcmlnaHQ/XFxuXFxuPGJyIC8+XFxuXFxuTGV0cyB0cnkgYSBmZXcgbW9yZSBleGFtcGxlcyBiZWZvcmUgbW92aW5nIG9uLiBDaGVjayB0aGUgY29tbWVudHMgb24gdGhlIGNvZGU6XFxuXFxuYGBganNcXG5jb25zdCBhcnJheSA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF07XFxuXFxuLy8gR2V0IG9ubHkgb2RkIG51bWJlcnNcXG5hcnJheS5maWx0ZXIodmFsdWUgPT4gdmFsdWUgJiAxKTsgLy8gWzEsIDMsIDUsIDcsIDldXFxuXFxuLy8gR2V0IG9ubHkgZXZlbiBudW1iZXJzXFxuYXJyYXkuZmlsdGVyKHZhbHVlID0+ICEodmFsdWUgJiAxKSk7IC8vIFsyLCA0LCA2LCA4LCAxMF1cXG5cXG4vLyBHZXQgdmFsdWVzIGJldHdlZW4gYDNgIGFuZCBgOGBcXG5hcnJheS5maWx0ZXIodmFsdWUgPT4gdmFsdWUgPiAzICYmIHZhbHVlIDwgOCk7IC8vIFs0LCA1LCA2LCA3XVxcbmBgYFxcblxcbkFzIHlvdSBjYW4gc2VlIHdlIGNhbiB1c2UgYGZpbHRlcigpYCBpbiBtYW55IHdheXMsIGxldHMgcGxheVxcbmEgbGl0dGxlIGJpdCB3aXRoIGBzdHJpbmdzYCDwn5mCXFxuXFxuLS0tXFxuXFxuIyMgU3RyaW5nc1xcblxcbkFnYWluLCBsZXRzIHNldCB1cCBhIHNpbXBsZSBhcnJheTpcXG5cXG5gYGBqc1xcbmNvbnN0IGFycmF5ID0gW1xcXCJAdGVsbW9cXFwiLCBcXFwiaHR0cHM6Ly90ZWxtby5pbVxcXCIsIFxcXCJGdWxsc3RhY2sgRGV2ZWxvcGVyXFxcIl1cXG5gYGBcXG5cXG5MZXRzIGFzc3VtZSB3ZSB3YW50IHRvIGZpbHRlciBqdXN0IFVSTHMsIHNvLCB3ZVxcbmNhbiBmaWx0ZXIgc3RyaW5ncyB0aGF0IHN0YXJ0IHdpdGggYGh0dHBgIGFzIGFuIGV4YW1wbGU6XFxuXFxuYGBganM6M1xcbmNvbnN0IGFycmF5ID0gW1xcXCJAdGVsbW9cXFwiLCBcXFwiaHR0cHM6Ly90ZWxtby5pbVxcXCIsIFxcXCJGdWxsc3RhY2sgRGV2ZWxvcGVyXFxcIl07XFxuXFxuYXJyYXkuZmlsdGVyKHZhbHVlID0+IHZhbHVlLnN0YXJ0c1dpdGgoXFxcImh0dHBcXFwiKSk7XFxuYGBgXFxuXFxuVGhpcyB3aWxsIHJldHVybiBgW1xcXCJodHRwczovL3RlbG1vLmltXFxcIl1gLiBJIGxvdmUgSmF2YVNjcmlwdCFcXG5cXG5TaW5jZSB3ZSBrbm93IGhhbmRsZXJzIHN0YXJ0IHdpdGggYW4gYEBgLCB3ZSBjYW4gZG8gZXhhY3RseSB0aGUgc2FtZVxcbnRoaW5nIHRvIGZpbHRlciBhbGwgaGFuZGxlcnMsIGxldHMgYWRkIGEgZmV3IG1vcmUgZW50cmllcyBpbnRvIG91ciBhcnJheTpcXG5cXG5gYGBqc1xcbmNvbnN0IGFycmF5ID0gW1xcbiAgXFxcIlRlbG1vXFxcIiwgXFxcIkB0ZWxtb1xcXCIsIFxcXCJAY29kaW5naHViaW9cXFwiLCBcXFwiQ29kaW5nIEh1YlxcXCJcXG5dXFxuXFxuYXJyYXkuZmlsdGVyKHZhbHVlID0+IHZhbHVlLnN0YXJ0c1dpdGgoXFxcIkBcXFwiKSk7XFxuYGBgXFxuXFxuVGhpcyBzaG91bGQgcmV0dXJuIGBbXFxcIkB0ZWxtb1xcXCIsIFxcXCJAY29kaW5naHViaW9cXFwiXWAsIHN3ZWV0IVxcblxcbi0tLVxcblxcbiMjIE9iamVjdHNcXG5cXG5GaW5hbGx5LCBsZXRzIGp1c3QgZ28gdGhyb3VnaCBhIG1vcmUgY29tcGxleCBhcnJheSwgYW4gYXJyYXlcXG5vZiBvYmplY3RzLCBsZXRzIGFzc3VtZSBhbiBhcnJheSBvZiBwcm9maWxlczpcXG5cXG5gYGBqc1xcbmNvbnN0IHByb2ZpbGVzID0gW1xcbiAgeyBuYW1lOiBcXFwiVGVsbW9cXFwiLCBoYW5kbGVyOiBcXFwiQHRlbG1vXFxcIiwgZm9sbG93ZXJzOiAxMDAwIH0sXFxuICB7IG5hbWU6IFxcXCJDYXRhbGluXFxcIiwgaGFuZGxlcjogXFxcIkBjYXRhbGlubXBpdFxcXCIsIGZvbGxvd2VyczogMjAwMCB9LFxcbiAgeyBuYW1lOiBcXFwiTWFyY1xcXCIsIGhhbmRsZXI6IFxcXCJAX21hcmNiYVxcXCIsIGZvbGxvd2VyczogMzAwMCB9LFxcbl07XFxuYGBgXFxuXFxuTm93IGxldHMgdHJ5IGFuZCBmaWx0ZXIgcHJvZmlsZXMgdGhhdCBoYXZlIG1vcmUgdGhhbiBgMTAwMGAgZm9sbG93ZXJzOlxcblxcbmBgYGpzXFxucHJvZmlsZXMuZmlsdGVyKHZhbHVlID0+IHZhbHVlLmZvbGxvd2VycyA+IDEwMDApO1xcbmBgYFxcblxcbldpdGggdGhpcyBmaWx0ZXIgeW91IHNob3VsZCBnZXQ6XFxuXFxuYGBganNvblxcbltcXG4gIHtcXG4gICAgXFxcIm5hbWVcXFwiOiBcXFwiQ2F0YWxpblxcXCIsXFxuICAgIFxcXCJoYW5kbGVyXFxcIjogXFxcIkBjYXRhbGlubXBpdFxcXCIsXFxuICAgIFxcXCJmb2xsb3dlcnNcXFwiOiAyMDAwXFxuICB9LFxcbiAge1xcbiAgICBcXFwibmFtZVxcXCI6IFxcXCJNYXJjXFxcIixcXG4gICAgXFxcImhhbmRsZXJcXFwiOiBcXFwiQF9tYXJjYmFcXFwiLFxcbiAgICBcXFwiZm9sbG93ZXJzXFxcIjogMzAwMFxcbiAgfVxcbl1cXG5gYGBcXG5cXG5JbiB0aGUgZmlsdGVyIHlvdSBjYW4gZG8gYW5vdGhlciB0aGluZywgd2hpY2ggaXMgZGVzdHJ1Y3R1cmluZyB0aGVcXG5gZm9sbG93ZXJzYCBkaXJlY3RseSwgbGlrZSB0aGlzOlxcblxcbmBgYGpzXFxucHJvZmlsZXMuZmlsdGVyKCh7IGZvbGxvd2VycyB9KSA9PiBmb2xsb3dlcnMgPiAxMDAwKTtcXG5gYGBcXG5cXG4tLS1cXG5cXG5JIHdhcyBhYm91dCB0byBlbmQgdGhpcyB3cml0aW5nIG5vdywgYnV0Li4uIFdlIGNhbiBzdGlsbCB1c2UgYW5vdGhlclxcbmFwcHJvYWNoIGludG8gaG93IHdlIGZpbHRlciBhcnJheXMuXFxuXFxuPGJyIC8+XFxuXFxuTGV0cyBhc3N1bWUgd2UgaGF2ZSBhbiBhcnJheSB3aXRoIGBudW1iZXJzYCBhbmQgYHN0cmluZ3NgLCBhbmQgd2VcXG53YW50IHRvIGZpbHRlciB0aGUgYXJyYXkgdG8gcmV0dXJuIGp1c3QgdGhlIGBzdHJpbmdzYCwgaG93IGRvIHdlXFxuY2hlY2sgaW4gSmF2YVNjcmlwdCBpZiBzb21ldGhpbmcgaXMgYSBgc3RyaW5nYD9cXG5cXG5gYGBqc1xcbnR5cGVvZiBzb21ldGhpbmcgPT09IFxcXCJzdHJpbmdcXFwiXFxuYGBgXFxuXFxuUmlnaHQsIGxldHMgdGFrZSB0aGUgZm9sbG93aW5nIGV4YW1wbGU6XFxuXFxuYGBganNcXG5jb25zdCBhcnJheSA9IFsxLCAzLCBcXFwiVGVsbW9cXFwiLCA0LCA2LCBcXFwiQHRlbG1vXFxcIl07XFxuXFxuLy8gV2UgY2FuIHVzZSB0aGUgYHR5cGVvZmAgZGlyZWN0bHkgaW4gdGhlIGZpbHRlclxcbmFycmF5LmZpbHRlcih2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiKTtcXG5gYGBcXG5cXG5JdCBzaG91bGQgcmV0dXJuIGBbXFxcIlRlbG1vXFxcIiwgXFxcIkB0ZWxtb1xcXCJdYCwgYXdlc29tZSEgQnV0LCB3ZSBjYW5cXG5yZWZhY3RvciB0aGlzIGEgbGl0dGxlIGJpdCwgYXNzdW1lIHlvdSBtaWdodCB3YW50IHRvIHVzZSBhIGZ1bmN0aW9uXFxudGhhdCBjaGVja3MgaWYgKnNvbWV0aGluZyogaXMgYSBgc3RyaW5nYCwgbGV0cyB0YWtlIGEgbG9vazpcXG5cXG5gYGBqc1xcbmNvbnN0IGFycmF5ID0gWzEsIDMsIFxcXCJUZWxtb1xcXCIsIDQsIDYsIFxcXCJAdGVsbW9cXFwiXTtcXG5cXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXFxcInN0cmluZ1xcXCI7XFxufVxcblxcbmFycmF5LmZpbHRlcihpc1N0cmluZyk7XFxuYGBgXFxuXFxuVGhpcyByZXR1cm5zIGV4YWN0bHkgdGhlIHNhbWUgYFtcXFwiVGVsbW9cXFwiLCBcXFwiQHRlbG1vXFxcIl1gLCBidXQgbG9vayBob3dcXG5vdXIgYGZpbHRlcigpYCBnb3QgbXVjaCBjbGVhbmVyLCBhbmQgYm9udXMsIHlvdSBjYW4gcmUtdXNlIHRoZSBgaXNTdHJpbmcoKWBcXG5mdW5jdGlvbiBzb21ld2hlcmUgZWxzZS5cXG5cXG4+IE5vdGUgdGhhdCB0aGlzIGlzIG5vdCBhICoqcmlnaHQgd2F5Kiogb2YgZG9pbmcgdGhpbmdzIGFwcHJvYWNoLCB5b3Ugc2hvdWxkIHVzZSB3aGF0ZXZlciB5b3UgdGhpbmsgaXMgZml0cyB5b3UgYmVzdC5cXG5cXG48YnIgLz5cXG5cXG5UaGF0J3MgaXQsIGhvcGUgaXQgaGVscGVkIHNvbWVob3cg4pyM77iPXFxuXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==